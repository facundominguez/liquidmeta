\documentclass[11pt]{article}
\usepackage{amssymb,amsmath,amsthm}
\usepackage[margin=1.25in]{geometry}
\usepackage{graphicx,ctable,booktabs}
\usepackage{textcomp,stmaryrd}
\usepackage{mathpartir} 

\allowdisplaybreaks

\newtheorem{theorem}{Theorem}%[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

%%%%% Set up the header
\usepackage{fancyhdr}
\usepackage{extramarks} % fixes the buggy section numbering
\usepackage{comment}
\pagestyle{fancy}
\lhead{Liquid Meta}
\chead{}
\rhead{\thepage}
\renewcommand{\headrulewidth}{.3pt}
\setlength\voffset{-0.25in}
\setlength\textheight{648pt}

\newcommand{\al}{\alpha}
\newcommand{\eps}{\varepsilon}
\newcommand{\bind}{\hspace{0.05em}{:}\hspace{0.05em}} %x:t w/o space
\newcommand{\col}{\mathbin{:}}       % e : t with a little space
\newcommand{\lb}{\llbracket}         % [[
\newcommand{\rb}{\rrbracket}         % ]]
\newcommand{\step}{\hookrightarrow}
\newcommand{\many}{\hookrightarrow^*}

% purely font faces
\newcommand{\true}{\mathtt{true}}
\newcommand{\Int}{{\sf Int}}
\newcommand{\Bool}{{\sf Bool}}

\newcommand{\existype}[3]{\exists\, #1\bind #2.\, #3}
\newcommand{\polytype}[3]{\forall\, #1\bind #2.\, #3}
\newcommand{\functype}[3]{#1\bind #2 \rightarrow #3}
\newcommand{\foralltheta}{\forall\theta.\,\theta\in\lb\Gamma\rb}
\newcommand{\letin}[3]{{\tt let}\,#1\hspace{0.1em}{=}\hspace{0.1em}#2\,{\tt in}\,#3}
\newcommand{\dom}[1]{{\rm dom}(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{Liquid Meta}
\author{\textsc{Michael Borkowski} \\ (summarizing joint work with {\sc Ranjit Jhala} and {\sc Niki Vazou})}
\date{June 8, 2020}

\maketitle
\thispagestyle{empty}

\section{Our language $\lambda_2$}

We work with a polymorphic, typed lambda calculus with call-by-value semantics which is augmented by refinement types, dependent function types, and existential types. Our language is based on the Sprite language $\lambda$ in Jhala and Vazou's forthcoming manuscript [JV] and incorporates and extends aspects from the $\lambda^H$ of Vazou et al [VSJ$^+$14]. The existential types were used in a metatheory by Knowles and Flanagan [KF09].

We start with the syntax of term-level expressions in our language:

\begin{align*}
{\sf Values} \;\;\; v :&=\;\: {\tt true}, {\tt false}
                         {\kern 5em}& boolean\; constants\\
                   &\;\;|\quad 0, 1, 2, \ldots 
                         & integer \; constants\\
                   &\;\;|\quad x & variables\\
                   &\;\;|\quad \lambda x . e
                         & abstractions \\
                   &\;\;|\quad \Lambda \alpha\bind k .e
                         & type\; abstractions\\
                   &\;\;|\quad \wedge, \; \vee, \;\neg,\; 
                         \leftrightarrow,\; \leq,\; =                     
                         & built{\rm -}in\; primitives 
\end{align*}
\begin{align*}
{\sf Expressions} \;\;\; e :&=\;\: v {\kern 5 em}& values \\
	                &\;\;|\quad e_1\; e_2 & applications \\
	                &\;\;|\quad e\; [t] & type\; applications\\
	                &\;\;|\quad {\tt let}\; x = e_1
	                      \; {\tt in} \; e_2 & let\; expressions\\
	                &\;\;|\quad e_1 \col t & annotations \\
\end{align*}

Next, we give the syntax of the types and binding environments used in our language:

\begin{align*}
{\sf Basic\; types} \quad b :&=\;\;{\sf Bool}{\kern 5em}&booleans\\
                   &\;\;|\quad {\sf Int} &integers \\ \\
{\sf Types} \quad t :&=\;\; b\{r\} & refinement \\
                   &\;\;|\quad \al &type\; variables \\
                   &\;\;|\quad x\bind t_x \rightarrow t 
                   &dependent\; function\\
                   &\;\;|\quad \exists\, x\bind t_x.\, t 
                   &existential\\ 
                   &\;\;|\quad \forall\, \al\bind k.\, t
                   &polymorphic\\ \\
{\sf Kinds} \quad k :&= \;\; B &base\; kind \\
                   &\;\;|\quad\, * &star\; kind \\ \\
%\end{align*}
%\begin{align*}
{\sf Environments} \quad \Gamma :&=\;\; \varnothing
                   {\kern 5em}& empty \\
                   &\;\;|\quad \Gamma, x\bind t & bind\;variable\\
                   &\;\;|\quad \Gamma, \al\bind k & bind\;type\;variable\\
\end{align*}

Next, we give the syntax of the Boolean predicates and constraints involved in refinements and subtyping judgments. The ternary judgment $\vdash_B \; :$ is the typing judgment in the underlying System F calculus.

\begin{align*}
{\sf Refinements} \;\; r :&= \{x\col p\}  \\ \\
{\sf Predicates} \;\; p :&=\;\: \{ e \;|\; \exists\, \Gamma.\, 
                   \Gamma \vdash_B e : {\sf Bool}\}
                   {\kern 3 em}& expressions\; of\; type\; {\sf Bool} 
\end{align*}
In the metatheory here we require that all variables bound in the environment be distinct. In the mechanization we use the locally-named representation: free and bound variables become distinct objects in the syntax. All free variables have unique names and these names never conflict with bound variables, which eliminates the possibility of capture in substitution and the need to perform alpha-renamings during substitution. This came at the cost of needing formal lemmas which permit us to change the name of a variable bound in the environment to maintain the uniqueness of the free variables only.

Our definition of predicates above departs from the Sprite languages of [JV] by allowing predicates to be arbitrary expressions from the main language (which are Boolean typed under the appropriate binding environment).
In [JV] however, predicates are quantifier-free first-order formulae over a vocabulary of integers and a limited number of relations. We initially took this approach, but were unable to fully define the denotational semantics for this type of language. In particular, when we define closing substitutions we need to define the substitution of a type $\theta(t)$ as the type resulting from $t$ after performing substitutions for all variables bound to values in
$\theta = (x_1 \mapsto v_1, \ldots, x_n \mapsto v_n)$. Substituting arbitrary expressions into $t$ requires substituting arbitrary expressions into predicates, and it isn't clear how to do this for functions like $(\lambda x. x)$ without taking predicates to be all Boolean-typed program expressions. \\

Returning to our $\lambda_2$, we next define the operational semantics of the language. We treat the reduction rules (small step semantics) of the various built-in primitives as external to our language, and we denote by $\delta(c,v)$ a function specifying them. The reductions are defined in a curried manner, so for instance we have that 
$c\; v_1\; v_2 \many \delta(\delta(c,v_1),v_2)$. Currying gives us unary relations like $m\!\!\leq$ which is a partially evaluated version of the $\leq$ relation.
\begin{align*}
\delta(\wedge,\true) &:= \lambda x.\, x &
  \delta(\leftrightarrow,\true) &:= \lambda x.\, x\\
\delta(\wedge,{\tt false}) &:= \lambda x.\, {\tt false} &
  \delta(\leftrightarrow,{\tt false}) &:= \lambda x.\, \neg x\\
\delta(\vee,\true) &:= \lambda x.\, \true &
  \delta(\leq,m) &:= m\!\!\leq  \\
\delta(\vee,{\tt false}) &:= \lambda x.\, x &
  \delta(m\!\!\leq, n) &:= {\tt bval}(m \leq n)\\ 
\delta(\neg,\true) &:= {\tt false} & 
  \delta(=,m) &:= m\!\!= \\
\delta(\neg,{\tt false}) &:= \true &
  \delta(m\!\!=, n) &:= {\tt bval}(m = n)
\end{align*}

Now we give the reduction rules for the small-step semantics. In what follows, $e$ and its variants refer to an arbitrary expression, $v$ refers to a value, $x$ to a variable, and $c$  refers to a built-in primitive.  
\begin{mathpar} %%%%%%%%% SMALL-STEP SEMANTICS %%%%%%%%%%
\inferrule*[Right=E-Prim]{  }{c\; v \step \delta(c,v)} \and
\inferrule*[Right=E-App1]{e \step e'}{e\; e_1 \step e'\; e_1} \\
\inferrule*[Right=E-App2]{e \step e'}{v\; e \step v \; e'} \and
\inferrule*[Right=E-AppAbs]{ }
  {(\lambda x.\, e)\; v \step e[v/x]} \\
\inferrule*[Right=E-AppT]{e \step e'}{e\; [t] \step e'\; [t]} \and
\inferrule*[Right=E-AppTAbs]{ }
  {(\Lambda \al\bind k.\, e)\; [t] \step e[t/\al]} \\ 
\inferrule*[Right=E-Let]{ e_x \step e'_x}
  {\letin{x}{e_x}{e} \step \letin{x}{e'_x}{e}} \and
\inferrule*[Right=E-LetV]{ }{\letin{x}{v}{e} \step e[v/x]} \\
\inferrule*[Right=E-Ann]{e \step e'}{e \col t \step e' \col t}\and
\inferrule*[Right=E-AnnV]{ }{v \col t \step v}
\end{mathpar}

We give the details of the type substitution operation used above in {\sc E-AppTAbs}: {\em (note: decide on whether the type variable is a basic type or whether it  cannot be refined)}
\begin{align*}
b\{x\col p\}[t_\al/\al] :&= b\{x\col p[t_\al/\al]\} \\
\al[t_\al/\al] :&= t_\al \\
(\functype{x}{t_x}{t})[t_\al/\al] :&= \functype{x}{(t_x[t_\al/\al])}{t[t_\al/\al]} \\
(\existype{x}{t_x}{t})[t_\al/\al] :&= \existype{x}{(t_x[t_\al/\al])}{t[t_\al/\al]} \\
(\polytype{\al'}{k}{t})[t_\al/\al] :&= \polytype{\al'}{k}{t[t_\al/\al]} \quad\quad\quad\quad\quad\quad\quad\quad \al \neq \al'
\end{align*}

Next, we define the typing rules of our $\lambda_2$.
The type judgments in the language $\lambda_2$ will be denoted $\vdash$ with a colon between term and type. For clarity, we distinguish between this and other judgments by using $\vdash$ with a subscript in most other settings. For instance, the judgement $\Gamma \vdash_w t : k$ says that type $t$ is well-formed in environment $\Gamma$ and has kind $k$:
\begin{mathpar}      %%%%%%%%%%%% WELL-FORMEDNESS %%%%%%%%%%%%%
\inferrule*[Right=WF-Refn]{y\bind b, \lfloor\Gamma\rfloor \vdash_B e[y/x] : \Bool \quad\;\; y \not\in {\rm dom}(\Gamma)}
{\Gamma \vdash_w b\{x\col e\} : B} \and
\inferrule*[Right=WF-Kind]{\Gamma \vdash_w t : B}{\Gamma\vdash_w t : *} \\
\inferrule*[Right=WF-Var]{\al :k \in \Gamma}{\Gamma \vdash_w \al : k}\and
\inferrule*[Right=WF-Func]
{\Gamma \vdash_w t_x : k_x \quad\; y\bind t_x, \Gamma  \vdash_w t[y/x] : k \quad\; y \not\in {\rm dom}(\Gamma)}
{\Gamma \vdash_w x\bind t_x \rightarrow t : *} \\
\inferrule*[Right=WF-Exis]
{\Gamma \vdash_w t_x : k_x \quad y\bind t_x, \Gamma \vdash_w t[y/x] : k \quad y \not\in{\rm dom}(\Gamma)}
{\Gamma \vdash_w \exists\, x\bind t_x .\, t : k} \\
\inferrule*[Right=WF-Poly]
{\al'\bind k, \Gamma \vdash_w t[\al'/\al] : k_t \quad \al' \not\in 
{\rm dom}(\Gamma)}
{\Gamma \vdash_w \forall\,\al\bind k.t : * }
\end{mathpar}

The judgment $\vdash_w \Gamma$ says that the environment $\Gamma$ is well formed, meaning that variables are only bound to well-formed types. We adopt the convention that our environments grow from right to left.
\begin{mathpar}
\inferrule*[Right=WFE-Empty]{ }{\vdash_w \varnothing} \and
\inferrule*[Right=WFE-Bind]{\Gamma \vdash_w t_x : k_x  \quad \vdash_w \Gamma \quad x\not\in{\rm dom}(\Gamma)}{\vdash_w x\bind t_x, \Gamma}\\
\inferrule*[Right=WFE-BindT]{\vdash_w \Gamma \quad \al\not\in{\rm dom}(\Gamma)}{\vdash_w \al\bind k, \Gamma}
\end{mathpar}

Now we give the rules for the typing judgements. As with the reduction rules, we take the type of our built-in primitives to be external to our language. We denote by $ty(c)$ the function that specifies the most specific type possible for $c$. More details on $ty(c)$ are given in the next section.
In order to express the exact type of variables, we introduce a ``selfification'' function that strengthens a refinement we the condition that a value is equal to itself; this is key to derive the fine grained type of $\lambda x.x$ being $x\bind\Bool\{z\col \true\} \rightarrow \Bool\{z \col z = x\}$.
{\em The $=$ in the $z=x$ definition below is overloaded, but in our mechanization we would use either $z\leftrightarrow x$ or $z=x$ depending on the base type. But if we can refine type variables, then  $=$ should be polymorphic.}
\begin{align*}
{\rm self}(b\{z\col p\}, x):&= b\{z\col p \wedge z = x\} \\
{\rm self}(\al, x) :&= \al \\
{\rm self}(\functype{z}{t_z}{t}, x) :&= \functype{z}{t_z}{t} \\
{\rm self}(\existype{z}{t_z}{t}, x) :&= \existype{z}{t_z}{t} \\
{\rm self}(\polytype{\al}{k}{t}, x) :&= \polytype{\al}{k}{t} 
\end{align*}

\begin{mathpar}             %%%%%%%%%%%%% TYPING %%%%%%%%%%%%%%%%%%
\inferrule*[Right=T-Prim]{ty(c) = t}{\Gamma \vdash c : t} \and
\inferrule*[Right=T-Var]{x\bind t \in \Gamma}{\Gamma \vdash x:{\rm self}(t,x)}\and
\inferrule*[Right=T-App]
{\Gamma \vdash e \,:\, x\bind t_x \rightarrow t \qquad \Gamma \vdash e' : t_x}
{\Gamma \vdash e\; e' : \exists\, x\bind t_x.\, t} \\
\inferrule*[Right=T-Abs]
{y\bind t_x, \Gamma \vdash e[y/x]:t[y/x] \quad\; \Gamma\vdash_w t_x : k_x \quad\; y \not\in {\rm dom}(\Gamma)}
{\Gamma \vdash \lambda x.\, e \,:\, x\bind t_x \rightarrow t}\\
\inferrule*[Right=T-AppT]
{\Gamma \vdash e \,:\, \polytype{\al}{k}{s} \qquad \Gamma \vdash_w t : k}
{\Gamma \vdash e [t] : s[t/\al]} \\
\inferrule*[Right=T-AbsT]
{\al'\bind k, \Gamma \vdash e [\al'/\al] : t [\al'/\al] \quad\; 
 \al'\bind k, \Gamma \vdash_w t : k' \quad\; \al'\not\in {\rm dom}(\Gamma)}
{\Gamma \vdash \Lambda \al\bind k. e : \polytype{\al}{k}{t}} \\
\inferrule*[Right=T-Let]
{\Gamma \vdash e_x : t_x \quad\; y\bind t_x, \Gamma \vdash e_2[y/x] : t[y/x] \quad\; \Gamma \vdash_w t : k \quad\; y \not\in {\rm dom}(\Gamma)}
{\Gamma \vdash \letin{x}{e_x}{e} : t} \\
\inferrule*[Right=T-Ann]{\Gamma\vdash e:t \quad\; \Gamma \vdash_w t : k}{\Gamma\vdash e\col t\,:\,t}
\and \inferrule*[Right=T-Sub]
{\Gamma\vdash e:s \qquad \Gamma\vdash s<:t \qquad\Gamma\vdash_w t:k}
{\Gamma \vdash e : t}
\end{mathpar}

The last rule, {\sc T-Sub}, uses the subtyping judgement $\Gamma \vdash s <: t$. The subtyping rules are as follows:

\begin{mathpar}   %%%%%%%%%%%%%%%%%% SUBTYPING %%%%%%%%%%%%%%%%%%
\inferrule*[Right=S-Base]
{y\bind b\{x_1\col p_1\}, \Gamma \vdash_e p_2[y/x_2] \qquad y\not\in {\rm dom}(\Gamma)}
{\Gamma \vdash b\{x_1\col p_1\} <: b\{x_2\col p_2\}} \and 
\inferrule*[Right=S-Func]
{\Gamma \vdash s_2 <: s_1 \qquad y\bind s_2, \Gamma \vdash t_1[y/x_1] <: t_2[y/x_2] \qquad y \not\in {\rm dom}(\Gamma)}
{\Gamma \vdash x_1\bind s_1 \rightarrow t_1 <: x_2\bind s_2\rightarrow t_2} \\
\inferrule*[Right=S-Witn]
{\Gamma \vdash v_x : t_x \qquad \Gamma \vdash t <: t'[v_x/x]}
{\Gamma \vdash t <: \exists\, x\bind t_x.\, t'} \and
\inferrule*[Right=S-Bind] 
{y\bind t_x, \Gamma \vdash t[y/x] <: t' \quad y \not\in free(t')}
{\Gamma \vdash \exists\, x\bind t_x.\, t <: t'} \\
\inferrule*[Right=S-Poly]
{\al\bind k, \Gamma \vdash t_1[\al/\al_1] <: t_2[\al/\al_2] \qquad \al \not\in {\rm dom}(\Gamma) }
{\Gamma \vdash \polytype{\al_1}{k}{t_1} <: \polytype{\al_2}{k}{t_2}}\\
\end{mathpar}

The first rule above, {\sc S-Base}, uses the entailment judgement $\Gamma \vdash_e p$ which (roughly) states that predicate $p$ is valid (in the sense of a logical formula) when universally quantified over all variables bound in environment $\Gamma$.
We give the inference rule for the entailment judgement:

\begin{mathpar}
\inferrule*[Right=Ent-Pred]
{\forall\, \theta.\, \theta\in \lb\Gamma\rb \Rightarrow \theta(p) \many \true}
{\Gamma \vdash_e p}
\end{mathpar}


\section{Preliminaries}   %%%%%%%%%%% 2222222222222 %%%%%%%%

For clarity, we distinguish between different typing judgments with a subscript.  The type judgments in the underlying polymorphic lambda calculus (System F) will be denoted by $\vdash_B$ and a colon before the type. In order to speak about the base type underlying some type, we define a function that erases refinements in types:
\[
\lfloor b\{x:p\} \rfloor := b, \quad \lfloor \al \rfloor := \al, \quad
\lfloor x\bind t_x \rightarrow t\rfloor := \lfloor t_x \rfloor \rightarrow \lfloor t \rfloor, \quad
\lfloor \exists\, x\bind t_x.\, t\rfloor := \lfloor t\rfloor,
\quad{\rm and}\quad
\lfloor \polytype{\al}{k}{t} \rfloor := \polytype{\al}{k}{\lfloor t\rfloor}
\]
We start our development of the meta-theory by giving a definition of {\em type denotations}. Roughly speaking, the denotation of a type $t$ without type variables is the class of value terms $v$ with the correct underlying base type such that this term satisfies the refinement predicates that appear within the structure of $t$. We formalize this notion with a recursive definition:
\begin{align*}
\lb b \rb \,&:= \{ v \;|\; \varnothing \vdash_B v : b\}\\
\lb b\{x\col p\}\rb \,&:= 
  \{ v \;|\; (\varnothing \vdash_B v:b)
\,\wedge\, (%{\rm if}\, e \many v \,{\rm then}\, 
p[v/x] \many {\tt true})\} \\
\lb x\bind t_x \rightarrow t\rb \,&:= 
\{ v\,|\; (\varnothing \vdash_B v : \lfloor t_x\rfloor \rightarrow \lfloor t\rfloor ) \,\wedge\,
( \forall\, v_x \in \lb t_x \rb.\, v\; v_x \many v' \,{\rm such\, that}\, v' \in \lb t[v_x/x] \rb)\} 
\\
\lb \exists\, x\bind t_x .\, t\rb \,&:= 
\{ v \,|\; (\varnothing \vdash_B v : \lfloor t\rfloor ) \,\wedge\,
( \exists\, v_x \in \lb t_x \rb.\, v\in \lb t[v_x/x] \rb)\}
\\
\lb\polytype{\al}{k}{t}\rb \,&:= \{ v \,|\; 
( \varnothing \vdash_B v : \polytype{\al}{k}{\lfloor t \rfloor}) \,\wedge\,
( \forall\, t_\al.\, (\varnothing \vdash_w t_\al : k) \Rightarrow 
v\, [t_\al] \many v' \,{\rm such\, that}\, v' \in \lb t [t_\al/\al] \rb)
\}
\end{align*}
The denotation of a type variable $\al$ is undefined.

We also have the concept of the denotation of an environment $\Gamma$; we intuitively define this to be the set of all sequences of value bindings for the term variables and type bindings for the type variables in $\Gamma$ such that the values respect the denotations of the types of the corresponding variables.
A closing substitution is just a sequence of value bindings to variables:
\[
\theta = (x_1\mapsto v_1,\,\ldots,\, x_n\mapsto v_n, \al_1 \mapsto t_1, \,\ldots,\, \al_m\mapsto t_m)
\quad {\rm with\, all}\, x_i, \al_j\, {\rm distinct}
\]
% Note that here in the metatheory 
We use the shorthand $\theta(x)$ to refer to $v_i$ if $x = x_i$ and we use $\theta(\al)$ to refer to $t_j$ if $\al = \al_j$. We define $\theta(t)$ to be the type derived from $t$ by substituting for all variables in $\theta$:
\[
\theta(t) := t[v_1/x_1]\cdots[v_n/x_n][t_1/\al_1]\cdots[t_m/\al_m]
\]
Then we can formally define the denotation of an environment:
\begin{align*}
\lb \Gamma \rb := \{ \theta =& (x_1 \mapsto v_1,\ldots, x_n \mapsto v_n,  \al_1 \mapsto t_1, \,\ldots,\, \al_m\mapsto t_m) \\ \; | \;&
\forall\, (x:t) \in \Gamma.\, \theta(x) \in \lb\theta(t)\rb \;\wedge\;
\forall\, (\al:k) \in \Gamma.\, \varnothing \vdash_w \theta(\al) : k \}.
\end{align*}

For each built-in primitive constant or function $c$ we define $ty(c)$ to include the most specific possible refinement type for $c$.
\begin{align*}
ty(\true) :=&\; \Bool\{ x : x = \true \}\\
ty({\tt false}) :=&\; \Bool\{ x : x = {\tt false}\}\\
ty(3) :=&\; \Int\{ x : x = 3\} \\
ty(n) :=&\; \Int\{ x : x = n\} \\
ty(\wedge) :=&\; 	x\bind\Bool \rightarrow y\bind\Bool \rightarrow \Bool\{ v : v = x \wedge y\}\\
ty(\neg) :=&\; x\bind\Bool \rightarrow \Bool\{ y : y = \neg x\}\\
ty(\leq) :=&\; x\bind\Int \rightarrow y\bind\Int \rightarrow \Bool\{v : v = (x \leq y)\}\\
ty(m\!\!\leq) :=&\; n\bind\Int \rightarrow \Bool\{v : v = (m \leq n)\}\\
ty(=) :=&\; x\bind\al \rightarrow y\bind\al \rightarrow \Bool\{ v : v = (x = y) \} 
\end{align*}
and similarly for the others % $ty(\vee)$, $ty(=)$, and $ty(m\!\!=)$. 
Note that we use $m\!\!\leq$ to represent an arbitrary member of the infinite family of primitives $0\!\!\leq,\, 1\!\!\leq,\, 2\!\!\leq,\ldots$. Then by the definitions above we get our primitive typing lemma:
\begin{lemma}(Primitive Typing) For every primitive $c$, 
\begin{enumerate}
\item $\varnothing \vdash c : ty(c)$. % and $\varnothing \vdash_w ty(c)$.  
\item If $ty(c) = b\{x \col p\}$, then $\varnothing \vdash_w ty(c) : B$,\, $c \in \lb ty(c) \rb$ and for all $c'$ such that $c' \neq c$, $c' \not\in \lb ty(c)\rb$.
\item If $ty(c) = \functype{x}{t_x}{t}$, then $\varnothing \vdash_w ty(c) : * $ and for each $v \in \lb t_x\rb$, $\delta(c,v)$ is defined and we have both $\varnothing \vdash \delta(c,v) : t[v/x] $ and $\delta(c,v) \in \lb t[v/x] \rb$. Thus $c \in \lb ty(c) \rb$.
\end{enumerate}\label{prim-typing}
\end{lemma}

\section{Meta-theory}  %%%%%%%%%%%%%%% 333333333333 %%%%%%%%%%%%%

In this section, we seek to prove the operational soundness of our language $\lambda_1$. We begin by stating several standard properties and proving some basic facts used later on.

\begin{lemma}\label{value-sub}
Values are closed under substitution of variables for values. If $v$ is a value and $x \in {\rm free}(v)$ then for any value $v_x$, we have that $v[v_x/x]$ is also a value.
\end{lemma}

\begin{lemma}\label{step-determ}
The operational semantics of $\lambda_2$ are deterministic: For every expression $e$ there exists at most one term $e'$ such that $e \step e'$. (Moreover there exists at most one value term $v$ such that $e \many v$.)
\end{lemma}

\begin{lemma}\label{weakenings}
(Weakenings of Judgments) For any environments $\Gamma$, $\Gamma'$ and $x \not\in dom(\Gamma', \Gamma)$:
\begin{enumerate}
\item If $\Gamma', \Gamma \vdash e : t$ then $\Gamma', x\bind t_x, \Gamma \vdash e :  t$.
\item If $\Gamma', \Gamma \vdash s <: t$ then $\Gamma', x\bind t_x, \Gamma \vdash s <: t$.
\item If $\Gamma', \Gamma \vdash_e p$ then $\Gamma', x\bind t_x, \Gamma \vdash_e p$.
\item If $\Gamma', \Gamma \vdash_w t:k$ then $\Gamma', x\bind t_x, \Gamma \vdash_w t:k$.
\end{enumerate}
\end{lemma}
\begin{proof}
The proof is by mutual induction on the derivation trees of each type of judgment.
%(1) {\bf TODO}
%
%(2) {\bf TODO}
%
%(3) {\bf TODO}
%
%(4) {\bf TODO}
\end{proof}


\begin{lemma}\label{sub-refl}
(Reflexivity of $<:$) If $\Gamma \vdash_w t : k$ and $t$ is not a type variable then $\Gamma \vdash t <: t$.
\end{lemma} {\bf TODO: Write up the other two cases from my notes}

\begin{proof} We proceed by induction of the structure of the derivation of $\Gamma \vdash_w t : k$. {\em We could dispense with the hypothesis that $t \not\equiv \al$ by either making $\al$ a basic type or adding another subtyping rule that states $(\al\col k)\in\Gamma \Rightarrow \Gamma \vdash \al <: \al$}

{\bf Case} {\sc WF-Refn}: In the base case, we have $t \equiv b{x\col p}$ and $k \equiv B$. By inversion, we have for some $y \not\in \dom{\Gamma}$, the judgment $y\bind b, \lfloor \Gamma \rfloor \vdash_B p[y/x] : \Bool$. Let $\theta \in \lb y\bind b\{x\col p\}, \Gamma\rb$. Then we have that $\theta(y) \in \lb\theta(b\{x\col p\})\rb = \lb b\{x\col \theta(p)\}\rb$, and so $\theta(p)[\theta(y)/x] \many \true$. But $\theta(p)[\theta(y)/x] = \theta(p[y/x])$, and so by rule {\sc Ent-Pred}, $y\bind b\{x\col p\}, \Gamma \vdash_e p[y/x]$. By {\sc S-Base}, we conclude $\Gamma \vdash b\{x\col p\} <: b\{x \col p\}$.
	
{\bf Case} {\sc WF-Kind}:  We have $\Gamma \vdash_w t : *$ and by inversion we have $\Gamma \vdash_w t : B$. By induction, we get $\Gamma \vdash t <: t$ as desired.

{\bf Case} {\sc WF-Func}: 

{\bf Case} {\sc WF-Exis}:

{\bf Case} {\sc WF-Poly}: We have $t \equiv \Lambda\al\bind k.t'$ and $\Gamma \vdash_w\Lambda\al\bind k.t' : *$. By inversion we have for some $\al' \not \in {\rm dom}(\Gamma)$, 
$\al'\bind k, \Gamma\vdash_w t'[\al'/\al]: k_t$. By induction, we have
$\al'\bind k, \Gamma\vdash t'[\al'/\al] <: t'[\al'/\al]$. By rule {\sc S-Poly} we conclude that $\Gamma \vdash \polytype{\al}{k}{t'} <: \polytype{\al}{k}{t'}$.
\end{proof}

Our proof of the soundness theorems begin with several helping lemmas.

\begin{lemma}{(Type Denotations) Our typing and subtyping relations are sound with respect to the denotational semantics of our types:\\
1. If $\Gamma \vdash t_1 <: t_2$ then $\forall \theta. \theta \in \lb \Gamma \rb \Rightarrow \lb\theta(t_1)\rb \subseteq \lb\theta(t_2)\rb$.\\
2. If $\Gamma \vdash e : t$ %and $e$ reduces to a value $e\many v$
, then $\forall \theta. \theta \in \lb \Gamma \rb \Rightarrow \theta(e) \many v'$ such that $v' \in \lb\theta(t)\rb.$
}\label{type-denote}
\end{lemma}

The proof is by mutual induction on the derivation trees of the respective subtyping and typing judgements. The need for mutual induction contrasts with Lemma 4 of [VSJ$^+$14] and comes from the appearance of the typing judgement $\Gamma \vdash v_x : t_x $ in the antecedent of rule {\sc S-Witn}.
     
\begin{proof} 
(1) Suppose $\Gamma \vdash t_1 <: t_2$. We proceed by induction on the derivation tree of the subtyping relation.

{\bf Case} $\textsc{Sub-Base}$: We have that 
$\Gamma \vdash b\{x_1\col p_1\} <: b\{x_2\col p_2\}$ where $t_1 \equiv b\{x_1\col p_1\}$ and $t_2 \equiv b\{x_2\col p_2\}$.
By inversion, for some $y\not\in\dom{\Gamma}$ we have  
\[ y\bind b\{x_1\col p_1\}, \Gamma \vdash_e  p_2[y/x_2].\] 
By inversion of {\sc Ent-Pred} we have 
\begin{equation}\label{3.1.0}
\forall\,\theta'.\,\theta'\in\lb y\bind b\{x_1\col p_1\}, \Gamma \rb \Rightarrow \theta'(p_2[y/x_2]) \many \true.
\end{equation}
We need to show $\forall \theta.\; 
\theta \in \lb \Gamma \rb \Rightarrow 
\lb\theta(b\{x_1:p_1\})\rb \subseteq \lb\theta(b\{x_2:p_2\})\rb.$
Equivalently,
\begin{align}\label{3.1.1}
\forall\theta.\,\theta\in\lb\Gamma\rb \Rightarrow&
\{ v \,|\, \varnothing \vdash_B v:b \;\wedge\; 
  (\theta(p_1[v/x_1]) \many \true)\}\\
\subseteq &\{ v \,|\, \varnothing \vdash_B v:b \;\wedge\; 
  (\theta(p_2[v/x_2]) \many \true)\}\label{3.1.2}
\end{align}
Let $\theta \in \lb\Gamma\rb$ be a closing substitution and
let $v$ a term in $\lb\theta(t_1)\rb$. 
Then $\theta(t_1) = b\{x_1\col \theta(p_1)\}$ and $\theta(p_1[v/x_1]) \many \true$.
Let $\theta' = (y \mapsto v, \theta) \in \lb y\bind b\{ x_1\col p_1\}, \Gamma\rb$.
By (\ref{3.1.0}) we have
$ \theta'(p_2[y/x_2]) \many \true$ and $\theta'(p_2[y/x_2]) = \theta(p_2[y/x_2][v/y]) = \theta(p_2[v/x_2])$,
which proves $v \in \lb\theta(t_2)\rb$.

{\bf Case} $\textsc{Sub-Func}$: We have that
$\Gamma \vdash x_1\bind s_1 \rightarrow t'_1 <: x_2\bind s_2 \rightarrow t'_2$ where $t_1 \equiv x_1\bind s_1 \rightarrow t'_1$ and $t_2 \equiv x_2\bind s_2 \rightarrow t'_2$. By inversion of this rule, for some $y\not\in\dom{\Gamma}$,
\[
\Gamma \vdash s_2 <: s_1 \;\;\;\;{\rm and}\;\;\;\;
y\bind s_2, \Gamma \vdash t'_1[y/x_1] <: t'_2[y/x_2]
\]
By the inductive hypothesis,
\[
\forall\theta.\, \theta \in \lb\Gamma\rb \Rightarrow
\lb\theta(s_2)\rb \subseteq\lb\theta(s_1)\rb 
\]
and
\begin{equation}\label{3.2.0}
\forall\theta'.\, \theta' \in \lb y\bind s_2,\Gamma\rb \Rightarrow
\lb\theta'(t'_1[y/x_1])\rb \subseteq\lb\theta'(t'_2[y/x_2])\rb 
\end{equation}
We need to show $\forall \theta.\; 
\theta \in \lb \Gamma \rb \Rightarrow 
\lb\theta(x_1\bind s_1\rightarrow t'_1)\rb \subseteq \lb\theta(x_2\bind s_2\rightarrow t'_2)\rb.$
Equivalently,
\begin{align} \label{3.2.1}
\forall\theta.\,\theta\in\lb\Gamma\rb \Rightarrow&
\{ v \,|\, \varnothing \vdash_B v:\lfloor s_1\rfloor \rightarrow \lfloor t'_1\rfloor \;\wedge\; 
  (\forall\, v' \in \lb \theta(s_1)\rb.\, v\,v' \many v^* \in\lb \theta(t'_1)[v'/x_1]\rb)\}\\
\subseteq &\{ v \,|\, \varnothing \vdash_B v:\lfloor s_2\rfloor \rightarrow \lfloor t'_2\rfloor \;\wedge\; 
  (\forall\, v' \in \lb \theta(s_2)\rb.\, v\,v' \many v^* \in\lb \theta(t'_2)[v'/x_2]\rb)\}\label{3.2.2} 
\end{align}
Fix $\theta \in \lb\Gamma\rb$ and let $v$ be a term in set (\ref{3.2.1}) and let $v' \in \lb \theta(s_2)\rb$. Then by induction, $v' \in \lb \theta(s_1)\rb$. So there exists a value $v^*$ such that $(v\, v') \many v^*$ and $v^* \in \lb(\theta(t'_1)[v'/x_1]\rb$. Let $\theta' = (y \mapsto v', \theta)$.  From (\ref{3.2.0}) we also have that 
$\lb\theta'(t'_1[y/x_1])\rb \subseteq \lb\theta'(t'_2[y/x_2])\rb$.
But $\theta'(t'_1[y/x_1]) = \theta(t'_1[y/x_1])[v'/y] = \theta(t'_1)[v'/x_1]$ and $\theta'(t'_2[y/x_2]) = \theta(t'_2)[v'/x_2]$.
Therefore  $v^* \in \lb \theta(t'_1)[v'/x_2]\rb \subseteq \lb \theta(t'_2)[v'/x_2]\rb$ and so $v$ is in set (\ref{3.2.2}) as desired.

{\bf Case} $\textsc{Sub-Witn}$: We have that
$\Gamma \vdash t_1 <: \exists\, x\bind t_x.\, t'_2$ where $t_2 \equiv \exists\, x\bind t_x.\, t'_2$. By inversion, there exists some value term $v_x$ such that
\[
\Gamma \vdash v_x : t_x \quad {\rm and} \quad \Gamma \vdash t_1 <: t'_2[v_x/x].
\]
By the inductive hypothesis, we have 
\begin{equation}\label{3.3.1}
\forall\, \theta.\, \theta\in \lb\Gamma\rb \Rightarrow \lb \theta(t_1) \rb \subseteq \lb \theta(t'_2[v_x/x]) \rb 
\end{equation}
and by mutual induction we also have that there exists a value $v'$ such that
\[
\forall\, \theta.\, \theta\in \lb\Gamma\rb \Rightarrow \theta(v_x) \many v' \in \lb\theta(t_x)\rb;
\]
values are closed under substitution and cannot be reduced further, so we must have that $v' = \theta(v_x)$.
We need to show that $\forall\, \theta$, if $\theta \in \lb\Gamma\rb$, then $\lb\theta(t_1)\rb \subseteq \lb \theta(\exists\, x\bind t_x.\, t'_2)\rb$. Fix some $\theta \in \lb\Gamma\rb.$ Then
\begin{equation} \label{3.3.2}
\lb \theta(\exists\, x\bind t_x.\, t'_2)\rb
= \{ v \,|\, \varnothing \vdash_B v : \lfloor \theta(t'_2)\rfloor \;\wedge\; 
  (\exists\, v' \in \lb \theta(t_x)\rb.\, v \in\lb \theta(t'_2)[v'/x]\rb)\}
\end{equation}
because $\theta(\exists\, x\bind t_x.\, t'_2) = \exists\, x\bind\theta(t_x).\, \theta(t'_2).$
Let $v \in \lb\theta(t_1)\rb$ and let $v' = \theta(v_x) \in \lb\theta(t_x)\rb$ be as above.
Then by (\ref{3.3.1}), $v \in \lb\theta(t'_2[v_x/x])\rb = \lb\theta(t'_2)[\theta(v_x)/x]\rb = \lb\theta(t'_2)[v'/x]\rb$.
By \ref{3.3.1} and by definition of the denotation of a type, $\varnothing \vdash_B v : \lfloor \theta(t'_2[v_x/x])\rfloor = \lfloor\theta(t'_2)\rfloor$. Therefore $v$ is in the right hand side of (\ref{3.3.2}).

{\bf Case} $\textsc{Sub-Bind}$: We have that $\Gamma \vdash \exists\, x\bind t_x.\, t'_1 <: t_2$ where $t_1 \equiv \exists\, x\bind t_x.\, t'_1$. By inversion we have for some $y \not\in\dom{\Gamma}$
\[
y\bind t_x,\Gamma\vdash t'_1[y/x] <: t_2 \quad {\rm and}\quad y \not\in free(t_2).
\]
By the inductive hypothesis, we have
\begin{equation}
\forall\,\theta'.\, \theta'\in\lb y\bind t_x,\Gamma\rb \Rightarrow \lb\theta'(t'_1[y/x])\rb \subseteq \lb\theta'(t_2)\rb.
\label{3.4.1}	
\end{equation}
We need to show that for every $\theta \in \lb\Gamma\rb$ that it holds that $\lb \theta(\exists\, x\bind t_x.\, t'_1)\rb \subseteq \lb\theta(t_2)\rb$. Fix some $\theta \in \lb\Gamma\rb$ and let $v \in \lb \theta(\exists\, x\bind t_x.\, t'_1)\rb$. By definition, $\theta(\exists\, x\bind t_x.\, t'_1) = \exists\, x\bind \theta(t_x).\, \theta(t'_1)$ so
\begin{equation}\label{3.4.2}
\lb \theta(\existype{x}{t_x}{t'_1})\rb = \{ v \,|\, \varnothing \vdash_B v: \lfloor\theta(t'_1)\rfloor \;\wedge\; (\exists\,v' \in \lb\theta(t_x)\rb.\, v \in \lb\theta(t'_1)[v'/x]\rb)\}.
\end{equation}
Take $v'$ as in (\ref{3.4.2}) and let $\theta' = (y\mapsto v', \theta)$. We note that $\theta' \in \lb y\bind t_x,\Gamma\rb$ because $\theta'(y) = v' \in \lb\theta(t_x)\rb = \lb\theta'(t_x)\rb$ where the last equality follows from the fact that $x$ cannot appear free in $t_x$. Then $v \in \lb\theta(t'_1)[v'/x]\rb = \lb\theta(t'_1[y/x])[v'/y]\rb = \lb\theta'(t'_1[y/x])\rb$, so from (\ref{3.4.1}) we can conclude $v \in \lb\theta'(t_2)\rb = \lb\theta(t_2)\rb$ because $y$ does not appear free in $t_2$ so $\theta'(t_2)=\theta(t_2)$. 

{\bf Case} $\textsc{Sub-Poly}$: We have that
$\Gamma \vdash \polytype{\al_1}{k}{t'_1} <: \polytype{\al_2}{k}{t'_2}$, where $t_1 \equiv \polytype{\al_1}{k}{t'_1}$ and $t_2 \equiv \polytype{\al_2}{k}{t'_2}$.
By inversion, for some $\al\not\in\dom{\Gamma}$, $\al\bind k,\Gamma \vdash t_1[\al/\al_1] <: t_2 [\al/\al_2]$.
By the inductive hypothesis, we have that for all $\theta' \in \lb \al\bind k, \Gamma\rb$ we have 
$\lb \theta'(t_1[\al/\al_1]) \rb \subseteq \lb \theta'( t_2[\al/\al_2] )\rb$.
We need to show \[\forall\theta.\; \theta \in \lb\Gamma\rb \Rightarrow \lb \theta(\polytype{\al_1}{k}{t_1})\rb \subseteq \lb \theta(\polytype{\al_2}{k}{t_2})\rb.\] 
Let $\theta \in \lb\Gamma\rb$ arbitrary and let $v \in \lb\theta( \polytype{\al_1}{k}{t_1})\rb = \lb\polytype{\al_1}{k}{\theta(t_1)}\rb$. Then $\varnothing \vdash_B v : \polytype{\al_1}{k}{\lfloor \theta(t_1) \rfloor}$. By Lemma \ref{erase-subtypes}, we also have $\varnothing \vdash_B v : \polytype{\al_2}{k}{\lfloor \theta(t_2) \rfloor}$ because $\lfloor \theta(t_1) \rfloor = \lfloor \theta(t_1[\al/\al_1]\rfloor = \lfloor \theta(t_2[\al/\al_2]) \rfloor = \lfloor \theta(t_2) \rfloor$. 
Now let $t_\al$ be a type such that $\varnothing \vdash_w t_\al : k$. Then we have that there exists a value $v'$ such that 
$v\, [t_\al] \many v'$ and $v' \in \lb \theta(t_1)[t_\al/\al_1]\rb = \lb\theta(t_1[\al/\al_1])[t_\al/\al]\rb.$
Let $\theta' = (\al \mapsto t_\al, \theta)$. Then $v' \in \lb\theta'(t_1[\al/\al_1])\rb$ and by induction we have
\[
v' \in \lb\theta'(t_2[\al/\al_2])\rb = \lb\theta(t_2[\al/\al_2])[t_\al/\al]\rb = \lb \theta(t_2)[t_\al/\al_2]\rb.
\]
This proves that $v \in \lb\polytype{\al_2}{k}{\theta(t_2)}\rb = \lb\theta(\polytype{\al_2}{k}{t_2})\rb$ as desired.\\

(2) Suppose $\Gamma \vdash e : t$. % and $e \many v$. 
We proceed by induction on the derivation tree of the typing relation. 

{\bf Case} {\sc T-Prim}: We have $\Gamma \vdash e : t$ where $e \equiv c$, a built-in primitive function or constant. By inversion, $ty(c) = t$. Let $\theta \in \lb \Gamma \rb$.
In one case $t \equiv b\{x\col p\}$; then by Lemma \ref{prim-typing} on constants, $\theta(c) = c \in \lb ty(c)\rb = \lb \theta(ty(c))\rb$. In the other case, $ty(c) \equiv \functype{x}{t_x}{t'}$; by Lemma \ref{prim-typing},
$c\; v_x \step \delta(c,v_x) \in \lb t'[v_x/x]\rb$ for any $v_x \in \lb t_x\rb.$ There are no free variables in $c$ or $t$ so $\theta(c)$ is a value and $\theta(c) = c \in \lb ty(c)\rb = \lb\theta(ty(c))\rb$.


{\bf Case} {\sc T-Var}: We have $\Gamma \vdash e : t$ where $e \equiv x$ and $t \equiv {\rm self}(t', x)$. By inversion, $(x\bind t') \in \Gamma$. Then for any $\theta \in \lb\Gamma\rb,$ we have by definition $\theta(x) \in \lb \theta(t')\rb$. If ${\rm self}(t', x) = t'$ then we are done; otherwise $t' \equiv b\{z\col p\}$ and ${\rm self}(t', x) = b\{z \col p \wedge z = x\}$. Then $\theta({\rm self}(t', x)) = b\{z\col \theta(p) \wedge z = \theta(x)\}$. We have $\varnothing\vdash_B \theta(x) : \lfloor {\rm self}(t', x) \rfloor$ because $\lfloor {\rm self}(t', x)\rfloor = \lfloor t'\rfloor$.
Finally, we have $\theta(p\wedge z = x)[\theta(x)/z] 
= \theta(p)[\theta(x)/z] \wedge \theta(x)=\theta(x) \many \true$
because $\theta(p)[\theta(x)/z] \many \true$ from $\theta(x)\in\lb b\{z\col \theta(p)\}\rb.$ Therefore $\theta(x) \in \lb\theta({\rm self}(t',x))\rb$, as desired.

% move TApp here

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\bf Case} {\sc T-AbsT}. We have $\Gamma \vdash e : t$ where $e \equiv \Lambda \al\bind k. e'$ and $t \equiv \polytype{\al}{k}{t'}$. By inversion we have $\al\bind k, \Gamma \vdash e' : t'$, and by the inductive hypothesis,
\begin{equation}\label{3.15}
\forall\, \theta'.\, \theta' \in \lb\al\bind k, \Gamma\rb \Rightarrow
\theta'(e') \in \lb\theta'(t')\rb.
\end{equation}
Let $\theta \in \lb\Gamma\rb$ arbitrary and let $t_\al$ be a type such that $\varnothing \vdash_w t_\al : k$. Then we have $\theta' := (\al \mapsto t_\al, \theta).$ Then from (\ref{3.15}), we have \[
\theta(e')[t_\al/\al] = \theta'(e') \in \lb \theta'(t')\rb = \lb\theta(t')[t_\al/\al]\rb.
\]
By the closure of values under substitution, $\theta(e')[t_\al/\al]$ is itself a value and by rule {\sc E-AppTAbs} we have that $\theta(\Lambda \al\bind k. e')\, [t_\al] \many \theta(e')[t_\al/\al]$, which proves that $\theta(e) \in \lb\theta(\polytype{\al}{k}{t'})\rb$.

%%%%%%%%%%%%%%%%%%%% include the bare typing judgment reasoning
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


{\bf Case} {\sc T-App}: We have $\Gamma \vdash e : t$ where $e \equiv e'\; e_x$ and $t \equiv \existype{x}{t_x}{t'}$. By inversion,
$\Gamma \vdash e' : \functype{x}{t_x}{t'}$ and $\Gamma \vdash e_x : t_x$. 
By the inductive hypothesis we have both
                                                                                                                                                                                                                                                                                                                                            
\begin{equation}\label{3.8.1}
\forall \theta.\, \theta\in\lb\Gamma\rb \Rightarrow 
\theta(e') \in \lb\theta(\functype{x}{t_x}{t'})\rb\end{equation}
and
\begin{equation}\label{3.8.2}
\forall \theta.\, \theta \in \lb\Gamma\rb \Rightarrow
\theta(e_x) \in \lb\theta(t_x)\rb.
\end{equation}

First suppose,



Next suppose that $\theta(e_x)$ does not evaluate to a value. Then 
$\theta(e')\;\theta(e_x)$ cannot evaluate to a value ever (because the only rule we could ever apply is {\sc E-App1} and no expression of the form $e'_1\;e'_2$ is ever a value)

From (\ref{3.8.1}), we have that for all $\theta \in \lb\Gamma\rb$, $\theta(e')\; \theta(e_x) \in \lb\theta(t')[\theta(e_x)/x]\rb$. Thus
\begin{equation}
\theta(e) = \theta(e')\; \theta(e_x) \in \lb \existype{x}{\theta(t_x)}{\theta(t')}\rb = \lb\theta(\existype{x}{t_x}{t'})\rb
.\end{equation}



{\bf Case} {\sc T-Abs}: We have $\Gamma \vdash e : t$ where $e \equiv \lambda x.e'$ and $t \equiv \functype{x}{t_x}{t'}$. By inversion, $\Gamma,x\bind t_x \vdash e' : t'$ and by the inductive hypothesis,
\begin{equation}\label{3.7.1}
\forall\theta'.\, \theta' \in \lb\Gamma,x\bind t_x\rb \Rightarrow \theta'(e') \in \lb\theta'(t')\rb.\end{equation}
Let $\theta \in \lb\Gamma\rb$ and let $v_x \in \lb \theta(t_x)\rb$ a value. Then let
\[\theta' := (\theta,x\mapsto v_x) \in \lb\Gamma,x\bind t_x\rb.
\] 
%because we chose $\theta(x) = \theta(v) \in \lb\theta(t_1)\rb$.
Then from (\ref{3.7.1}), 
\begin{equation}\label{3.7.2}
\theta(e')[v_x/x] = \theta'(e') \in \lb\theta'(t')\rb = \lb\theta(t')[v_x/x]\rb.
\end{equation}

We need to show that for every $\theta \in \lb\Gamma\rb$, it holds that 
\begin{align*}
\theta(e) \in \lb \theta(&\functype{x}{t_x}{t'}) \rb = \lb \functype{x}{\theta(t_x)}{\theta(t')}\rb\\
=&\; \{ \hat{e} \;|\; (\varnothing \vdash_B {\hat e} : \lfloor t_x \rfloor \rightarrow \lfloor t' \rfloor) \wedge ( \forall\, \hat v_x \in \lb \theta(t_x) \rb.\; \hat e \; \hat v_x \in \lb\theta(t')[\hat v_x/x] \rb) \}
\end{align*}
We have $\varnothing \vdash_B \theta(e) : \lfloor t_x \rfloor \rightarrow \lfloor t' \rfloor$ because substitutions do not affect bare types, only the refinement predicates.
We have
$\theta(e)\; v_x = (\lambda x.\theta(e'))\; v_x.$
%There are two cases for $e_x$: first, if $e_x$ does not evaluate to any value then the only reduction rules we can ever apply are {\sc E-App1} and {\sc E-App2} and so $\theta(e)\; e_x$ can never evaluate to a value. By Lemma \ref{denote-diverge} we have that $\theta(e)\; e_x \in \lb t'[e_x/x]\rb$. In the other case suppose that there exists some value such that $e_x \many v_x$. 
Then  $\theta(e)\; v_x \step \theta(e')[v_x/x] \in \lb \theta(t')[v_x/x]\rb$. By Lemma \ref{pres-den}, we conclude that $\theta(e)\; v_x \in \lb \theta(t')[v_x/x]\rb$ also.
%By a forthcoming lemma (TODO: this), $\lb\theta(t')[v_x/x]\rb \subseteq \lb\theta(t')[e_x/x]\rb$. Then by Lemma \ref{denote-diverge} we conclude that $\theta(e)\; e_x \in \lb\theta(t')[e_x/x]\rb$ and so $\theta(e) \in \lb\theta(t)\rb$.



{\bf Case} {\sc T-Let}: We have $\Gamma \vdash e : t$ where
$e \equiv \letin{x}{e_x}{e'}$.
By inversion, we have $\Gamma \vdash e_x : t_x$,\; $(\Gamma,x\bind t_x) \vdash e' : t$, and $\Gamma \vdash_w t$
for some $t_x$. Then by the inductive hypothesis we have
\[
\foralltheta \Rightarrow \theta(e_x) \in \lb\theta(t_x)\rb
\] and 
\begin{equation}\label{3.9.1}
\forall\theta'.\, \theta' \in \lb\Gamma,x\bind t_x\rb \Rightarrow \theta'(e') \in \lb\theta'(t)\rb.\end{equation}
Let $\theta \in \lb\Gamma\rb$. There are two cases for the semantics of $e_x$. In the case that there exists some value $v_x$ such that $\theta(e_x) \many v_x$, let $\theta' = (\theta, x\mapsto v_x)\in \lb\Gamma,x\bind t_x\rb$ because we chose $\theta'(x) = v_x \in \lb\theta(t_x)\rb$. 
From the operational semantics $\theta(\letin{x}{e_x}{e'}) = \letin{x}{\theta(e_x)}{\theta(e')} \many \letin{x}{v_x}{\theta(e')} \step \theta(e')[v_x/x]$. 
Then from (\ref{3.9.1}),
\[
\theta(e')[v_x/x] = \theta'(e') \in \lb\theta'(t)\rb = \lb\theta(t)[v_x/x]\rb = \lb\theta(t)\rb,
\]
where the last equality follows from the fact that the judgement $\Gamma \vdash_w t$ implies $\varnothing \vdash_w \theta(t)$ by part 3 of this lemma, which in turn implies that $x$ cannot be free in $\theta(t)$.
The above implies
$\theta(e) \many \theta(e')[v_x/x]$, so by Lemma \ref{pres-den}, $\theta(e) \in \lb\theta(t)\rb$.

In the second case, $\theta(e_x)$ does not reduce to any value. In that case, the only rule we can ever apply to $\theta(e) = \letin{x}{\theta(e_x)}{\theta(e')}$ is {\sc E-Let} so $\theta(e)$ never reduces to a value, and by Lemma \ref{denote-diverge} $\theta(e) \in \lb\theta(t)\rb$.

{\bf Case} {\sc T-Ann}: We have $\Gamma \vdash e : t$ where $e \equiv (e'\col t)$. By inversion, $\Gamma \vdash e' : t$ and by the inductive hypothesis, $\theta(e') \in \lb\theta(t)\rb$. By the operational semantics of type annotations, 
$\theta(e) = (\theta(e')\col\theta(t)) \step \theta(e') \in \lb\theta(t)\rb$, so we conclude that $\theta(e) \in \lb\theta(t)\rb$ by Lemma \ref{pres-den}.

{\bf Case} {\sc T-Sub}: We have $\Gamma \vdash e : t $ and by inversion, we have $\Gamma \vdash e : s$ and $\Gamma \vdash s <: t$ for some type $s$. 
By the inductive hypothesis, $\foralltheta \Rightarrow \theta(e) \in \lb\theta(s)\rb$ and by mutual induction, part 1 of the Lemma gives us that  $\foralltheta \Rightarrow \lb\theta(s)\rb \subseteq \lb\theta(t)\rb$. Then we conclude that $\foralltheta \Rightarrow \theta(e) \in \lb\theta(t)\rb$.
%
%{\bf Case} {\sc T-Bot}: We have $\Gamma \vdash \bot : t$ where $t \equiv b\{x \col p\}$. Then because $\bot$ cannot evaluate, we have that $\bot \in \lb b\{x\col \theta(p)\}\rb = \lb \theta(t)\rb$.
\end{proof}




\begin{comment}
\begin{proof}
(1) Suppose $\Gamma \vdash e_x:t_x$ and $\Gamma, x\bind t_x ,\Gamma' \vdash t_1 <: t_2$. We proceed by mutual induction on the derivation tree of the subtyping relation.

{\bf Case} $\textsc{Sub-Base}$: We have that 
$\Gamma,x\bind t_x,\Gamma' \vdash b\{x_1\col p_1\} <: b\{x_2\col p_2\}$ where $t_1 \equiv b\{x_1\col p_1\}$ and $t_2 \equiv b\{x_2\col p_2\}$.
By inversion, 
\[\Gamma,x\bind t_x,\Gamma',x_1\bind b\{x_1\col p_1\} \vdash p_2[x_1/x_2].\] 
By inversion of {\sc Ent-Ext} we have 
\begin{equation}\label{311}
\Gamma,x\bind t_x,\Gamma' \vdash \forall x_1\bind b.\; p_1 \Rightarrow p_2[x_1/x_2].\end{equation}
By Lemma \ref{decl-impl}, we have
\begin{align}
\forall\, \theta^*.\, \theta^* \in \lb \Gamma,x\bind t_x,\Gamma'\rb \Rightarrow \varnothing \;&\vdash_e \theta^*(\forall x_1\bind b.\; p_1 \Rightarrow p_2[x_1/x_2]) \\
&= \forall\, x_1\bind b.\, \theta^*(p_1) \Rightarrow \theta^*(p_2)[x_1/x_2].
\end{align}

Let $e_x$ be an expression such that $\Gamma \vdash e_x : t_x$.
The above is equivalent to:
\[
\forall\, \theta, \theta'.\, (\theta, x \mapsto \theta(e_x), \theta') \in \lb\Gamma, x\bind t_x, \Gamma'\rb \Rightarrow \big( \varnothing \vdash_e
\forall\, x_1\bind b.\, \theta'(\theta(p_1)[\theta(e_x)/x]) \Rightarrow \theta'(\theta(p_2)[\theta(e_x)/x]))[x_1/x_2] \big)
\]
or equivalently,
\begin{equation}
\forall\, \theta, \theta'.\, (\theta, \theta') \in \lb\Gamma, \Gamma'[e_x/x]\rb \Rightarrow \big(\varnothing \vdash_e
\forall\, x_1\bind b.\, (\theta, \theta')(p_1[e_x/x]) \Rightarrow (\theta,\theta')(p_2[e_x/x][x_1/x_2])\big)
\end{equation}

TODO: can't finish this one yet.
\begin{comment}
The validity of the implication in (\ref{311}) means that
\begin{equation}\label{312}
\forall\theta^*. \theta^*\in\lb\Gamma,x:t_x,\Gamma',v_1:b\rb \Rightarrow
(\theta^*(p_1)\many\true)\Rightarrow(\theta^*(p_2[v_1/v_2])\many\true)
\end{equation}

Let $(\theta,\theta',v_1\mapsto e_1) \in \lb\Gamma,\Gamma'[e_x/x],v_1:b\rb$ be a closing substitution. Then
\[(\theta,x\mapsto e_x,\theta',v_1\mapsto e_1)
\in \lb \Gamma,x:t_x,\Gamma',v_1:b\rb
\]
because for each $(y:t_y[e_x/x]) \in \Gamma'[e_x/x]$ we have
$\theta'(y) \in\lb\theta'(t_y[e_x/x])\rb$ which implies
$(x\mapsto e_x,\theta')(y) \in \lb(x\mapsto e_x,\theta')(t_y)\rb$.

Suppose it were the case that $(\theta,\theta',v_1\mapsto e_1)(p_1[e_x/x]) \many \true$. Then 
\[
(\theta,x\mapsto e_x,\theta',v_1\mapsto e_1)
(p_1) \many \true
\] and so by (\ref{312}) \[
(\theta,x\mapsto e_x,\theta',v_1\mapsto e_1)
(p_2[v_1/v_2]) \many \true
\]
which in turn implies
\[
(\theta,\theta',v_1\mapsto e_1)((p_2[v_1/v_2])[e_x/x]) \many\true.
\]
Using the fact that $(p_2[v_1/v_2])[e_x/x] = (p_2[e_x/x])[v_1/v_2]$,
this gives us the entailment 
\begin{equation}\label{313}
\Gamma,\Gamma'[e_x/x] \vdash \forall v_1:b.\, 
  p_1[e_x/x] \Rightarrow (p_2[e_x/x])[v_1/v_2]
\end{equation}
By {\sc Ent-Ext},
\[
\Gamma,\Gamma'[e_x/x],v_1:b\{p_1[e_x/x]\} \vdash (p_2[e_x/x])[v_1/v_2].
\]
By {\sc Sub-Base},
\[
\Gamma,\Gamma'[e_x/x] \vdash b\{v_1 : p_1[e_x/x]\} <: b\{ v_2 : p_2[e_x/x]\}
\]
We know $t_1[e_x/x] = b\{v_1 : p_1[e_x/x]\}$ and likewise $t_2[e_x/x] = b\{v_2:p_2[e_x/x]\}$.
Therefore, we conclude that 
$\Gamma,\Gamma'[e_x/x] \vdash t_1[e_x/x] <: t_2[e_x/x].$
\end{comment}
\begin{comment}

{\bf Case} $\textsc{Sub-Fun}$: We have that
$\Gamma, x:t_x,\Gamma' \vdash x_1:s_1 \rightarrow t'_1 <: x_2:s_2 \rightarrow t'_2$ where $t_1 \equiv x_1:s_1 \rightarrow t'_1$ and $t_2 \equiv x_2:s_2 \rightarrow t'_2$. By inversion
\[
\Gamma,x:t_x,\Gamma' \vdash s_2 <: s_1 \;\;\;\;{\rm and}\;\;\;\;
\Gamma,x:t_x,\Gamma',x_2:s_2 \vdash t'_1[x_2/x_1] <: t'_2
\]
Applying the inductive hypothesis to the above, we get
\begin{equation}\label{321}
\Gamma,\Gamma'[e_x/x] \vdash s_2[e_x/x] <: s_1[e_x/x]
\end{equation} 
and
\begin{equation}\label{322}
\Gamma,\Gamma'[e_x/x],x_2:s_2[e_x/x] \vdash (t'_1[x_2/x_1])[e_x/x] <: t'_2[e_x/x]
\end{equation}
We necessarily have that $x \neq x_1$ so
$(t'_1[x_2/x_1])[e_x/x] = (t'_1[e_x/x])[x_2/x_1]$.
By rule {\sc Sub-Fun} applied to (\ref{321}) and (\ref{322}),
\[
\Gamma,\Gamma'[e_x/x] \vdash x_1:s_1[e_x/x] \rightarrow t'_1[e_x/x] <: x_2:s_2[e_x/x] \rightarrow t'_2[e_x/x]
\]
This is the same as 
$\Gamma,\Gamma'[e_x/x] \vdash t_1[e_x/x] <: t_2[e_x/x]$.

(2) Suppose $\Gamma \vdash e_x:t_x$ and $\Gamma, x:t_x ,\Gamma' \vdash e : t$. We proceed by induction on the derivation tree of the typing judgment $e:t$.

{\bf Case} {\sc Syn-Var}: We have $\Gamma, x:t_x,\Gamma' \vdash e : t$ where $e \equiv y$. By inversion we have $(\Gamma,x:t_x,\Gamma')(y) = t$. There are three possibilities for where in the environment $y:t$ is bound.
First, suppose $\Gamma(y) = t$. Then, necessarily, $y\neq x$ and $y[e_x/x] = y.$ But $x:t_x$ is bound to the right of $\Gamma$, so $x$ cannot appear in $t$ and $t = t[e_x/x]$. By rule {\sc Syn-Var} we have $\Gamma, \Gamma'[e_x/x] \vdash y : t$ and so
$\Gamma, \Gamma'[e_x/x] \vdash y[e_x/x] : t[e_x/x] $.

Next suppose $y \equiv x$. Then $t \equiv t_x$. Also, $x:t_x$ is bound to the right of $\Gamma$, so $x$ cannot appear in $t_x$ (i.e. $x$ cannot be free in its own type). So $t_x = t_x[e_x/x] = t[e_x/x]$.
We also have $e_x = x[e_x/x] = y[e_x/x]$ and 
By hypothesis, $\Gamma \vdash e_x : t_x$ and this judgment remains true with respect to more bindings on variables that don't appear in $e_x$ or $t_x$; so $\Gamma,\Gamma'[e_x/x] \vdash e_x : t_x$. By the above equalities we see $\Gamma,\Gamma'[e_x/x] \vdash y[e_x/x] : t[e_x/x]$.

Finally, suppose $\Gamma'(y) = t$. 
Then $\Gamma'[e_x/x](y) = t[e_x/x]$. 
By rule {\sc Syn-Var} we have $\Gamma,\Gamma'[e_x/x] \vdash y : t[e_x/x]$. We necessarily have that $y\neq x$ and so $y[e_x/x] = y$. Thus we conclude
$\Gamma,\Gamma'[e_x/x] \vdash y[e_x/x] : t[e_x/x]$.


{\bf Case} {\sc Syn-Con}:We have $\Gamma, x:t_x,\Gamma' \vdash e : t$ where $e \equiv c$. By inversion, $t = {\sf prim}(c)$. By our assumptions on constants, neither $c$ nor ${\sf prim}(c)$ contain free variables so $c[e_x/x] = c$ and ${\sf prim}(c)[e_x/x]$.
By rule {\sc Syn-Con},
$\Gamma,\Gamma'[e_x/x] \vdash c : t$ and so
$\Gamma,\Gamma'[e_x/x] \vdash c[e_x/x] : t[e_x/x]$
because the environment can be artibrary.

{\bf Case} {\sc Syn-Ann}:We have $\Gamma, x:t_x,\Gamma' \vdash e : t$ where $e \equiv (e':t)$. By inversion, we have $\Gamma, x:t_x,\Gamma' \vdash e' : t$ and by the induction hypothesis, 
$\Gamma, \Gamma'[e_x/x] \vdash e'[e_x/x] : t[e_x/x]$. By rule {\sc Syn-Ann}, we get
\begin{equation}\label{351}
\Gamma, \Gamma'[e_x/x] \vdash (e'[e_x/x] : t[e_x/x]) : t[e_x/x]
\end{equation}
By definition of substitutions $(e'[e_x/x] : t[e_x/x]) = (e':t)[e_x/x] = e[e_x/x]$, so from (\ref{351}) we immediately get $\Gamma, \Gamma'[e_x/x] \vdash e[e_x/x] : t[e_x/x]$

{\bf Case} {\sc Syn-App}:We have $\Gamma, x:t_x,\Gamma' \vdash e : t$ where $e \equiv e'\, v$ and $t \equiv t'[v/y]$ for some value $v$ (per the syntax). By inversion,
$\Gamma, x:t_x, \Gamma' \vdash e' : (y:s'\rightarrow t')$
and $\Gamma, x:t_x, \Gamma' \vdash v : s'$.
By the inductive hypothesis,
\begin{equation}\label{361}
\Gamma,\Gamma'[e_x/x] \vdash e'[e_x/x] : (y:s'[e_x/x]\rightarrow t'[e_x/x])
\end{equation}
and
\begin{equation}\label{362}
\Gamma,\Gamma'[e_x/x] \vdash v[e_x/x] : s'[e_x/x.]
\end{equation}
By rule {\sc Syn-App}
\begin{equation}
\Gamma,\Gamma'[e_x/x] \vdash e'[e_x/x]\, v[e_x/x] : (t'[e_x/x])[v[e_x/x]/y]
\end{equation}
Now by the definition of substitutions we have
$e'[e_x/x]\, v[e_x/x] = (e'\;v)[e_x/x] \equiv e[e_x/x]$ and 
$(t'[e_x/x])[v[e_x/x]/y] = (t'[v/y])[e_x/x] \equiv t[e_x/x]$.
Therefore, we conclude
$\Gamma,\Gamma'[e_x/x] \vdash e[e_x/x] : t[e_x/x]$.

{\bf Case} {\sc Chk-Syn}:We have $\Gamma, x:t_x,\Gamma' \vdash e : t$. By inversion, we have $\Gamma,x:t_x,\Gamma' \vdash e : s$
and $\Gamma, x:t_x, \Gamma' \vdash s <: t$ for some type $s$. By the inductive hypothesis we have
\begin{equation}
\label{371}
\Gamma,\Gamma'[e_x/x] \vdash e[e_x/x] : s[e_x/x]
\end{equation}
and by part (1) of the Lemma we have
\begin{equation}
\label{372}
\Gamma,\Gamma'[e_x/x] \vdash s[e_x/x] <: t[e_x/x].
\end{equation}
Then by rule {\sc Chk-Syn} we have
$\Gamma,\Gamma'[e_x/x] \vdash e[e_x/x] : t[e_x/x]$.

{\bf Case} {\sc Chk-Lam}:We have $\Gamma, x:t_x,\Gamma' \vdash e : t$ where $e \equiv \lambda y. e'$ 
and $t \equiv y:t_1 \rightarrow t_2$. By inversion,
$\Gamma, x:t_x,\Gamma',y:t_1 \vdash e' : t_2$. By the inductive hypothesis
\begin{equation}
\Gamma,\Gamma'[e_x/x],y:t_1[e_x/x] \vdash e'[e_x/x] : t_2[e_x/x].
\end{equation}
Then by rule {\sc Chk-Lam}
\begin{equation}
\Gamma,\Gamma'[e_x/x] \vdash \lambda y.(e'[e_x/x]) : (y:t_1[e_x/x] \rightarrow t_2[e_x/x]).
\end{equation}
By definition of substitution, we can rewrite the above as
\[
\Gamma,\Gamma'[e_x/x] \vdash (\lambda y.e')[e_x/x] : (y:t_1 \rightarrow t_2)[e_x/x].
\]

{\bf Case} {\sc Chk-Let}:We have $\Gamma, x:t_x,\Gamma' \vdash e : t$ where $e \equiv (\letin{y}{e_1}{e_2})$ and $t \equiv t_2$. By inversion, $\Gamma,x:t_x,\Gamma' \vdash e_1 : t_1$ and 
$\Gamma,x:t_x,\Gamma',y:t_1 \vdash e_2 : t_2$ for some type $t_1$. By the inductive hypothesis we have
\begin{equation}
\Gamma,\Gamma'[e_x/x] \vdash e_1[e_x/x] : t_1[e_x/x]
\end{equation}and
\begin{equation}
\Gamma,\Gamma'[e_x/x], y:t_1[e_x/x] \vdash e_2[e_x/x] : t_2[e_x/x]
\end{equation}
Then by rule {\sc Chk-Let},
\begin{equation}
\Gamma,\Gamma'[e_x/x] \vdash \letin{y}{e_1[e_x/x]}{e_2[e_x/x]} : t_2[e_x/x]
\end{equation}
which we can write as
\[
\Gamma,\Gamma'[e_x/x] \vdash (\letin{y}{e_1}{e_2})[e_x/x]:t_2[e_x/x]
\] to complete the proof of the final case.
%\end{comment}
\end{proof}





























\newpage {\sc Most recently updated} 


\begin{lemma}(The Substitution Lemma) If $\Gamma \vdash e_x : t_x$ then\\
1. If $\Gamma, x\bind t_x, \Gamma' \vdash t_1 <: t_2$ then
\[
\Gamma, \Gamma'[e_x/x] \vdash t_1[e_x/x] <: t_2[e_x/x].
\]
2. If $\Gamma, x\bind t_x, \Gamma' \vdash e : t$ then
\[
\Gamma, \Gamma'[e_x/x] \vdash e[e_x/x] : t[e_x/x].
\]
3. If $\Gamma, x\bind t_x, \Gamma' \vdash_w t$ then
\[
\Gamma, \Gamma'[e_x/x] \vdash_w t[e_x/x]
\]
\end{lemma}

\begin{proof}
We proceed by mutual induction 	
	
	
	
	
\end{proof}

\begin{lemma}\label{types-wf}
(Well-formedness of types in judgements) 
If $\Gamma \vdash e: t$ and $\vdash_{w} \Gamma$ then $\Gamma \vdash_w t$.
\end{lemma}

\begin{proof} 
We proceed by induction on the derivation tree of the judgment $\varnothing \vdash e : t$.

{\bf Case} {\sc T-Prim}: We have $e \equiv c$. By inversion, $t = ty(c)$ and by Lemma \ref{prim-typing} we have $\varnothing \vdash_ w ty(c)$. By repeated application of Lemma \ref{weakenings}, we have $\Gamma \vdash_w ty(c)$. 

{\bf Case} {\sc T-Var}: We have $\Gamma \vdash e : t$ where $e \equiv x$. By inversion, $x\bind t \in \Gamma$, so we can write $\Gamma \equiv \Gamma', x\bind t,\Gamma''$ and by repeated inversion of {\sc WFE-Bind}, $\vdash_w \Gamma',x\bind t$ and inverting again we get $\Gamma' \vdash_w t$. Inductively applying Lemma \ref{weakenings} gives us $\Gamma \vdash_w t$.

{\bf Case} {\sc T-Abs}: We have $\Gamma \vdash e : t$ where $e \equiv \lambda x.\, e'$ and $t \equiv \functype{x}{t_x}{t'}$. By inversion, we have $\Gamma, x\bind t_x \vdash e : t'$ and $\Gamma \vdash_w t_x$. By the inductive hypothesis, we have $\Gamma, x\bind t_x \vdash_W t'$. By rule {\sc WF-Func} we have $\Gamma \vdash_w \functype{x}{t_x}{t'}$.

{\bf Case} {\sc T-App}: We have $\Gamma \vdash e : t$ where $e \equiv e_1\; e_2$ and $t \equiv \existype{x}{t_x}{t'}.$ By inversion, $\Gamma \vdash e_1 : \functype{x}{t_x}{t'}$ and $\Gamma \vdash e_2 : t_x$. By the inductive hypothesis we have $\Gamma \vdash_w \functype{x}{t_x}{t'}$ and $\Gamma \vdash_w t_x$. By inverting rule {\sc WF-Func} (on the former judgement), we have $\Gamma \vdash_w t_x$ and $\Gamma,x\bind t_x \vdash_w t'$. By rule {\sc WF-Exis}, $\Gamma \vdash_w \existype{x}{t_x}{t'}$.

{\bf Case} {\sc T-Let}: We have $\Gamma \vdash e : t$ where $e \equiv \letin{x}{e_x}{e'}$. By inversion we have, in particular, that $\Gamma \vdash_w t$.

{\bf Case} {\sc T-Ann}: We have $\Gamma \vdash e : t$ where $e \equiv e'\col t$. By inversion we have $\Gamma \vdash e' : t$ and by the inductive hypothesis we conclude $\Gamma \vdash_w t$.

{\bf Case} {\sc T-Sub}: We have $\Gamma \vdash e : t$. By inversion we have, in particular, $\Gamma \vdash_w t$.
\end{proof}


\begin{lemma}\label{witness-sub}
(Witnesses and subtyping) If $\Gamma \vdash e_x : t_x$ and $\Gamma, x\bind t_x \vdash_w t'$ then $\Gamma \vdash t'[e_x/x] <: \existype{x}{t_x}{t'}$.
\end{lemma}
\begin{proof}
By Lemma \ref{sub-refl}, we have that $\Gamma \vdash t' <: t'$ and by the Substitution Lemma we have $\Gamma \vdash t'[e_x/x] <: t'[e_x/x]$.  Applying rule {\sc S-Witn} (with $t\equiv \existype{x}{t_x}{t'}$), we get $\Gamma \vdash t'[e_x/x] <: \existype{x}{t_x}{t'}$.
\end{proof}


\begin{theorem}\label{progress}
(The Progress Theorem) If $\varnothing \vdash e : t$ then either $e$ is a value or there exists a term $e'$ such that $e \hookrightarrow$ e'.
\end{theorem} {\bf TODO: Do I need crash?.}

\begin{proof} We proceed by induction on the derivation tree of the judgment $\varnothing \vdash e : t$.

{\bf Case} {\sc T-Prim}: This case holds trivially because $e \equiv c$ is a value.

{\bf Case} {\sc T-Var}: This case cannot occur because $\Gamma = \varnothing$.

{\bf Case} {\sc T-Abs}: This case holds trivially because $e \equiv \lambda x.e'$ is a value.

{\bf Case} {\sc T-App}: We have $\varnothing \vdash e : t$ where $e \equiv e_1\; e_2$ and $t \equiv \existype{x}{t_x}{t'}$. By inversion, $\varnothing \vdash e_1 : \functype{x}{t_x}{t'}$ and $\varnothing \vdash e_2 : t_x$ for some type $s$. We split on five cases for the structure of $e_1$ and $e_2$.

First, consider $e_1 \equiv c$ and $e_2 \equiv v$; then by rule {\sc E-Prim} $e \equiv c\; v \hookrightarrow \delta(c,v)$, which is defined by Lemma \ref{prim-typing}.
Second, consider $e_1 \equiv c$ and $e_2$ not a value. By the inductive hypothesis (applied to $\varnothing \vdash e_2 : t_x$), there exists a term $e'_2$ such that $e_2 \step e'_2$. Thus $e_1\; e_2 \step e_1 \; e'_2$ by rule {\sc E-App1}.

Third, consider $e_1 \equiv \lambda x.e'_1$ and $e_2 \equiv v$. Then by the operational semantics, $\lambda x.e_2 \; v \step e_2[v/x]$. Fourth, consider $e_1 \equiv \lambda x.e'_1$ and $e_2$ not a value. By the inductive hypothesis, there exists a term $e'_2$ such that $e_2 \step e'_2$. Thus $e_1\; e_2 \step e_1 \; e'_2$ by {\sc E-App1} again.

This exhausts all possible cases in which $e_1$ could be a value in the empty environment. So, finally, consider $e_1$ not a value. Then by the inductive hypothesis there exists $e'_1$ such that $e_1 \hookrightarrow e'_1$. By the operational semantics, $e_1\; e_2 \hookrightarrow e'_1\; e_2$.

{\bf Case} {\sc T-Let}: We have $\varnothing \vdash e : t$ where
$e \equiv (\letin{x}{e_1}{e_2})$. By inversion, $\varnothing \vdash e_1:t_x$ and $x\bind t_x\vdash e_2: t$. First, suppose that $e_1 \equiv v$. Then by rule {\sc T-LetV}, $\letin{x}{v}{e_2} \step e_2[v/x]$. Second, suppose that $e_1$ is not a value. Then by the inductive hypothesis (applied to judgement $\varnothing \vdash e_1:t_x$), there exists a term $e'_1$ such that $e_1 \step e'_1$. Then by rule {\sc E-Let} we have $\letin{x}{e_1}{e_2} \step \letin{x}{e'_1}{e_2}$.

{\bf Case} {\sc T-Ann}: We have $\varnothing \vdash e : t$ where $e \equiv (e_1\col t)$. By inversion, $\varnothing \vdash e_1 : t$. By the inductive hypothesis either $e_1 \equiv v$ a value or there exists $e'_1$ such that $e_1 \hookrightarrow e'_1$. In the former case $(v\col t) \hookrightarrow v$ and in the latter case $(e_1\col t) \hookrightarrow (e'_1\col t)$.

{\bf Case} {\sc T-Sub}: We have $\varnothing \vdash e : t$. By inversion, $\varnothing \vdash e : s$, $\varnothing \vdash s <: t$, and $\varnothing \vdash_w t$ for some type $s$. By the inductive hypothesis, either $e$ is a value or there exists $e'$ such that $e \hookrightarrow e'$ and we are done.
\end{proof}

\begin{theorem}(The Preservation Theorem)
If $\varnothing \vdash e : t$ and $e \hookrightarrow e'$, then $\varnothing \vdash e' : t$.	
\end{theorem} {\bf Todo: Do I need crash?}
\begin{proof} We proceed by induction on the derivation tree of the judgment $\varnothing \vdash e : t$.

{\bf Case} {\sc T-Con}: Holds trivially because if $e \equiv c$ then there does not exist $e'$ such that $c \hookrightarrow e'$.

{\bf Case} {\sc T-Var}: Holds trivially because if $e \equiv x$ then there does not exist $e'$ such that $x \hookrightarrow e'$.

{\bf Case} {\sc T-Abs}: Holds trivially because if $e \equiv \lambda x.e_1$ then there does not exist any $e'$ such that $\lambda x.e_1 \hookrightarrow e'$.

{\bf Case} {\sc T-App}: We have $\varnothing \vdash e : t$ where $e \equiv e_1\; e_2$ and $t \equiv \existype{x}{t_x}{t'}$ for some variable $x$ and type $t_x$. By inversion, $\varnothing \vdash e_1 : \functype{x}{t_x}{t'}$ and $\varnothing \vdash e_2 : t_x$. We split on five cases for the structure of $e_1$ and $e_2$.

First, consider $e_1 \equiv c$ and $e_2 \equiv v$; then by the semantics $e' = \delta(c,v)$ and by Lemma \ref{prim-typing}, we have $\varnothing \vdash \delta(c,v) : t'[v/x]$ because n. By Lemma \ref{types-wf}, we have $\varnothing \vdash_w \existype{x}{t_x}{t'}$ and by inverting {\sc WF-Exis} we have $x\bind t_x \vdash_w t'$. By Lemma \ref{witness-sub}, $\varnothing \vdash t'[v/x] <: \existype{x}{t_x}{t'}$, and so by rule {\sc T-Sub}, $\varnothing \vdash \delta(c,v) : \existype{x}{t_x}{t'} $.

Second, consider $e_1 \equiv c$ and $e_2$ not a value. By Theorem \ref{progress}, there exists a term $e'_2$ such that $e_2 \step e'_2$. By rule {\sc E-App2}, $c\; e_2 \step c\; e'_2$ and by the determinism of the operational semantics, $e' \equiv c\; e'_2$.
By the inductive hypothesis, $\varnothing \vdash e'_2 : t_x$. We conclude by {\sc T-App} that $\varnothing \vdash e' : \existype{x}{t_x}{t'}$.

Third, consider $e_1 \equiv \lambda x.e'_1$ and $e_2 \equiv v$. Then $e_1\; e_2 \step e'_1[v/x]$ and by determinism of the operational semantics, $e' \equiv e'_1[v/x]$. By inversion of {\sc T-Abs}, we have $x\bind t_x \vdash e'_1 : t'$, and by the substitution lemma we have $\varnothing \vdash e'_1[v/x] : t'[v/x]$. By Lemma \ref{types-wf}, we have $\varnothing \vdash_w \existype{x}{t_x}{t'}$ and by inverting {\sc WF-Exis} we have $x\bind t_x \vdash_w t'$. By Lemma \ref{witness-sub}, $\varnothing \vdash t'[v/x] <: \existype{x}{t_x}{t'}$, and so by rule {\sc T-Sub}, $\varnothing \vdash e' : \existype{x}{t_x}{t'}$.

Fourth, consider $e_1 \equiv \lambda x.e'_1$ and $e_2$ not a value. By Theorem \ref{progress}, there exists a term $e'_2$ such that $e_2 \step e'_2$. By rule {\sc E-App2}, $(\lambda x.e'_1)\; e_2 \step (\lambda x.e'_1)\; e'_2$ and by the determinism of the operational semantics, $e' \equiv (\lambda x.e'_1)\; e'_2$.
By the inductive hypothesis, $\varnothing \vdash e'_2 : t_x$. We conclude by {\sc T-App} that $\varnothing \vdash e' : \existype{x}{t_x}{t'}$.

This exhausts all possible cases in which $e_1$ could be a value in the empty environment. So, finally, consider $e_1$ not a value.
Then by Theorem \ref{progress}, there exists an $e'_1$ such that $e_1 \hookrightarrow e'_1$. By determinism of the operational semantics, $e' \equiv e'_1\; e_2$. By the inductive hypothesis,
$\varnothing \vdash e'_1 : \existype{x}{t_x}{t'}$. By rule {\sc Syn-App}, $\varnothing \vdash e' : \existype{x}{t_x}{t'}$.

{\bf Case} {\sc T-Let}: We have $\varnothing \vdash e : t$ where $e \equiv (\letin{x}{e_1}{e_2})$ and $t \equiv t_2$. By inversion,
$\varnothing \vdash e_1 : t_1$,\quad $x\bind t_1\vdash e_2 : t_2$, and $\varnothing \vdash_w t_2$ for some type $t_1$. 
First suppose that $e_1$ is not a value. Then by Theorem \ref{progress}, there exists some term $e'_1$ such that $e_1 \step e'_1$. By Rule {\sc E-Let}, $\letin{x}{e_1}{e_2} \step \letin{x}{e'_1}{e_2}$, and by determinism of the operational semantics, $e' \equiv \letin{x}{e'_1}{e_2}$. By the inductive hypothesis, $\varnothing \vdash e_1 : t_1$. Then by {\sc T-Let}, $\varnothing \vdash e' : t_2$.

Second, suppose that $e_1 \equiv v$, for some value $v$. Then by rule {\sc E-LetV}, $\letin{x}{v}{e_2}\step e_2[v/x]$. By determinism of the operational semantics, $e' \equiv e_2[v/x]$. By the substitution lemma, $\varnothing \vdash e_2[v/x] : t_2[v/x]$. But by $\varnothing vdash_w t_2$, we know that $x$ does not appear free in $t_2$ so $t_2[v/x] = t_2$ and $\varnothing \vdash e' : t_2$.

{\bf Case} {\sc T-Ann}: We have $\varnothing \vdash e : t$ where $e \equiv (e_1 : t)$ and $e \hookrightarrow e'$. By inversion,
$\varnothing \vdash e_1 : t$. By Theorem \ref{progress} there exists $e'_1$ such that $e_1 \hookrightarrow e'_1$. By rule {\sc E-Ann} $(e_1 : t) \hookrightarrow (e'_1 : t)$ and by the determinism of the operational semantics we must have $e' \equiv (e'_1 : t)$. Then by the inductive hypothesis, $\varnothing \vdash e'_1 : t$. By rule {\sc Syn-Ann}, $\varnothing \vdash (e'_1 : t) : t$. 

{\bf Case} {\sc T-Sub}: We have $\varnothing \vdash e : t$. By inversion $\varnothing \vdash e : s$ and $\varnothing \vdash s <: t$ for some type $s$, and also $\varnothing \vdash_w t$. By the inductive hypothesis $\varnothing \vdash e' : s$. By rule {\sc Chk-Syn}, $\varnothing \vdash e' : t$.
\end{proof}

\section{Algorithmic Typing} %%%%%%%% 444444 %%%%%%%%%%%%%%

\begin{lemma}\label{SMT-Entails}
(Denotational Soundness of SMT) If $\Gamma \vdash p$ then $\Gamma \vdash_e p$.
\end{lemma}


\newpage
General Todo list:
\begin{itemize}
	\item does having call-by-value (non-lazy) semantics affect wha the definitions of denotations of types ($\lb \; \rb$) ought to be? Should any expressions being substituted into types become values?
	\item In Lemma 5, case {\sc T-Abs} requires some additional lemma like: if $e \many v$ then $\lb t[v/x] \rb \subseteq \lb t[e/x] \rb$
	\item Lemma 5 needs a part (3): If $\Gamma \vdash_w t$ then $\foralltheta \Rightarrow \varnothing \vdash_w \theta(t)$.
	\item The entailment rules don't quite seem to fit with the denotation definitions. Can't prove case {\sc S-Base} in the Substitution Lemma (Lemma 6).
	
\end{itemize}
\end{comment}
\end{document}